/*!
 * devextreme-react
 * Version: 19.2.5
 * Build date: Mon Dec 16 2019
 *
 * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tree_1 = require("./tree");
var utils_1 = require("./utils");
function getChanges(current, prev) {
    var changesAccum = {
        options: {},
        removedOptions: [],
        templates: {},
        addRemovedValues: function (currentOptions, prevOptions, path) {
            appendRemovedValues(currentOptions, prevOptions, path, this.removedOptions);
        }
    };
    compare(current, prev, changesAccum);
    return changesAccum;
}
exports.getChanges = getChanges;
function compare(current, prev, changesAccum) {
    if (!prev) {
        changesAccum.options[current.fullName] = tree_1.buildNode(current, changesAccum.templates, true);
        return;
    }
    changesAccum.addRemovedValues(current.options, prev.options, current.fullName);
    changesAccum.addRemovedValues(current.configCollections, prev.configCollections, current.fullName);
    changesAccum.addRemovedValues(current.configs, prev.configs, current.fullName);
    compareCollections(current, prev, changesAccum);
    for (var _i = 0, _a = Object.keys(current.configs); _i < _a.length; _i++) {
        var key = _a[_i];
        compare(current.configs[key], prev.configs[key], changesAccum);
    }
    for (var _b = 0, _c = Object.keys(current.options); _b < _c.length; _b++) {
        var key = _c[_b];
        if (current.options[key] === prev.options[key]) {
            continue;
        }
        changesAccum.options[utils_1.mergeNameParts(current.fullName, key)] = current.options[key];
    }
    compareTemplates(current, prev, changesAccum);
}
function compareTemplates(current, prev, changesAccum) {
    var currentTemplatesOptions = {};
    var currentTemplates = {};
    var prevTemplatesOptions = {};
    var prevTemplates = {};
    tree_1.buildTemplates(current, currentTemplatesOptions, currentTemplates);
    tree_1.buildTemplates(prev, prevTemplatesOptions, prevTemplates);
    changesAccum.addRemovedValues(currentTemplatesOptions, prevTemplatesOptions, current.fullName);
    // TODO: support switching to default templates
    // appendRemovedValues(currentTemplates, prevTemplates, "", changesAccum.templates);
    for (var _i = 0, _a = Object.keys(currentTemplatesOptions); _i < _a.length; _i++) {
        var key = _a[_i];
        if (currentTemplatesOptions[key] === prevTemplatesOptions[key]) {
            continue;
        }
        changesAccum.options[utils_1.mergeNameParts(current.fullName, key)] = currentTemplatesOptions[key];
    }
    for (var _b = 0, _c = Object.keys(currentTemplates); _b < _c.length; _b++) {
        var key = _c[_b];
        var currentTemplate = currentTemplates[key];
        var prevTemplate = prevTemplates[key];
        if (prevTemplate && currentTemplate.content === prevTemplate.content) {
            continue;
        }
        changesAccum.templates[key] = currentTemplate;
    }
}
function appendRemovedValues(current, prev, path, changesAccum) {
    var removedKeys = Object.keys(prev).filter(function (key) { return Object.keys(current).indexOf(key) < 0; });
    for (var _i = 0, removedKeys_1 = removedKeys; _i < removedKeys_1.length; _i++) {
        var key = removedKeys_1[_i];
        changesAccum.push(utils_1.mergeNameParts(path, key));
    }
}
function compareCollections(current, prev, changesAccum) {
    var _loop_1 = function (key) {
        var currentCollection = current.configCollections[key];
        var prevCollection = prev.configCollections[key] || [];
        if (!currentCollection || currentCollection.length !== prevCollection.length) {
            var updatedCollection_1 = [];
            currentCollection.map(function (item) {
                var config = tree_1.buildNode(item, changesAccum.templates, true);
                updatedCollection_1.push(config);
            });
            changesAccum.options[utils_1.mergeNameParts(current.fullName, key)] = updatedCollection_1;
            return "continue";
        }
        for (var i = 0; i < currentCollection.length; i++) {
            compare(currentCollection[i], prevCollection[i], changesAccum);
        }
    };
    for (var _i = 0, _a = Object.keys(current.configCollections); _i < _a.length; _i++) {
        var key = _a[_i];
        _loop_1(key);
    }
}
